#!/usr/bin/env python3
# Color Picker using GTK4, similar to cheatsheet script

import gi
gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, Gdk, Gio, GLib
import sys
import subprocess
import socket
import threading
import os
import tempfile


def rgb_to_hsv(r, g, b):
    r, g, b = r / 255.0, g / 255.0, b / 255.0
    mx = max(r, g, b)
    mn = min(r, g, b)
    df = mx - mn
    if mx == mn:
        h = 0
    elif mx == r:
        h = (60 * ((g - b) / df) + 360) % 360
    elif mx == g:
        h = (60 * ((b - r) / df) + 120) % 360
    elif mx == b:
        h = (60 * ((r - g) / df) + 240) % 360
    if mx == 0:
        s = 0
    else:
        s = (df / mx) * 100
    v = mx * 100
    return h, s, v


def hsv_to_rgb(h, s, v):
    s /= 100.0
    v /= 100.0
    c = v * s
    x = c * (1 - abs((h / 60) % 2 - 1))
    m = v - c
    if 0 <= h < 60:
        r, g, b = c, x, 0
    elif 60 <= h < 120:
        r, g, b = x, c, 0
    elif 120 <= h < 180:
        r, g, b = 0, c, x
    elif 180 <= h < 240:
        r, g, b = 0, x, c
    elif 240 <= h < 300:
        r, g, b = x, 0, c
    elif 300 <= h < 360:
        r, g, b = c, 0, x
    r, g, b = (r + m) * 255, (g + m) * 255, (b + m) * 255
    return int(round(r)), int(round(g)), int(round(b))


def rgb_to_hex(r, g, b):
    return f"#{r:02x}{g:02x}{b:02x}"

def hex_to_rgb(hex_str):
    try:
        hex_str = hex_str.lstrip('#')
        if len(hex_str) != 6:
            return None
        return tuple(int(hex_str[i:i+2], 16) for i in (0, 2, 4))
    except ValueError:
        return None


class ColorPickerWindow(Gtk.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app)
        self.set_title("Color Picker")
        self.set_default_size(400, 400)
        self.set_resizable(False)

        self.updating = False
        self.cursor_over = False

        # Parse initial color
        self.r, self.g, self.b = 255, 0, 0  # Red
        self.h, self.s, self.v = rgb_to_hsv(self.r, self.g, self.b)
        self.hex_value = rgb_to_hex(self.r, self.g, self.b)

        # Live mode
        self.live_mode = False
        self.timeout_id = None
        self.updating_live = False

        # Socket for key press (kept for compatibility)
        self.socket_path = "/tmp/color_picker_socket"
        if os.path.exists(self.socket_path):
            os.remove(self.socket_path)
        self.server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.server.bind(self.socket_path)
        self.server.listen(1)
        self.last_x, self.last_y = None, None
        self.thread = threading.Thread(target=self.listen_socket)
        self.thread.daemon = True
        self.thread.start()
        self.connect("destroy", self.on_destroy)

        # Aero style frosted glass CSS using theme colors
        # Aero style frosted glass CSS
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(b"""
window {
    background-color: rgba(184, 212, 240, 0.7);
    background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(0, 0, 0, 0.1) 100%);
    color: #000000;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.6);
}
frame {
    background-color: rgba(255, 255, 255, 0.7);
    color: #000000;
    border-radius: 5px;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), 0 1px 2px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(0, 0, 0, 0.1);
}
button {
    background-color: rgba(255, 255, 255, 0.8);
    color: #000000;
    border-radius: 5px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(0, 0, 0, 0.2);
}
button:hover {
    background-color: rgba(255, 255, 255, 0.9);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
}
entry {
    background-color: rgba(255, 255, 255, 0.9);
    color: #000000;
    border-radius: 3px;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.2);
}
spinbutton {
    background-color: rgba(255, 255, 255, 0.9);
    color: #000000;
    border-radius: 3px;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.2);
}
label {
    color: #000000;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
}
""")
        Gtk.StyleContext.add_provider_for_display(Gdk.Display.get_default(), css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

        # Main box
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_top(20)
        box.set_margin_bottom(20)
        box.set_margin_start(20)
        box.set_margin_end(20)
        self.set_child(box)

        motion_controller = Gtk.EventControllerMotion()
        motion_controller.connect("enter", self.on_enter)
        motion_controller.connect("leave", self.on_leave)
        self.add_controller(motion_controller)

        # Gesture for button press to show hex in live mode
        gesture = Gtk.GestureClick()
        gesture.connect("pressed", self.on_button_press)
        self.add_controller(gesture)



        # Pick color button
        pick_button = Gtk.Button()
        pick_button.set_icon_name("gtk-select-color")
        pick_button.connect("clicked", self.on_pick)
        box.append(pick_button)

        # Color swatch
        color_frame = Gtk.Frame(label="Color")
        self.color_area = Gtk.DrawingArea()
        self.color_area.set_size_request(200, 200)
        self.color_area.set_draw_func(self.draw_color)
        color_frame.set_child(self.color_area)
        box.append(color_frame)

        # Separator
        sep = Gtk.Separator()
        box.append(sep)

        # RGB section
        rgb_frame = Gtk.Frame(label="RGB")
        rgb_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        rgb_box.set_margin_top(10)
        rgb_box.set_margin_bottom(10)
        rgb_box.set_margin_start(10)
        rgb_box.set_margin_end(10)

        self.r_spin = Gtk.SpinButton()
        self.r_spin.set_range(0, 255)
        self.r_spin.set_value(self.r)
        self.r_spin.connect("value-changed", self.on_rgb_changed)

        self.g_spin = Gtk.SpinButton()
        self.g_spin.set_range(0, 255)
        self.g_spin.set_value(self.g)
        self.g_spin.connect("value-changed", self.on_rgb_changed)

        self.b_spin = Gtk.SpinButton()
        self.b_spin.set_range(0, 255)
        self.b_spin.set_value(self.b)
        self.b_spin.connect("value-changed", self.on_rgb_changed)

        rgb_box.append(Gtk.Label(label="R:"))
        rgb_box.append(self.r_spin)
        rgb_box.append(Gtk.Label(label="G:"))
        rgb_box.append(self.g_spin)
        rgb_box.append(Gtk.Label(label="B:"))
        rgb_box.append(self.b_spin)
        rgb_frame.set_child(rgb_box)
        box.append(rgb_frame)

        # HSV section
        hsv_frame = Gtk.Frame(label="HSV")
        hsv_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        hsv_box.set_margin_top(10)
        hsv_box.set_margin_bottom(10)
        hsv_box.set_margin_start(10)
        hsv_box.set_margin_end(10)

        self.h_spin = Gtk.SpinButton()
        self.h_spin.set_range(0, 360)
        self.h_spin.set_value(self.h)
        self.h_spin.connect("value-changed", self.on_hsv_changed)

        self.s_spin = Gtk.SpinButton()
        self.s_spin.set_range(0, 100)
        self.s_spin.set_value(self.s)
        self.s_spin.connect("value-changed", self.on_hsv_changed)

        self.v_spin = Gtk.SpinButton()
        self.v_spin.set_range(0, 100)
        self.v_spin.set_value(self.v)
        self.v_spin.connect("value-changed", self.on_hsv_changed)

        hsv_box.append(Gtk.Label(label="H:"))
        hsv_box.append(self.h_spin)
        hsv_box.append(Gtk.Label(label="S:"))
        hsv_box.append(self.s_spin)
        hsv_box.append(Gtk.Label(label="V:"))
        hsv_box.append(self.v_spin)
        hsv_frame.set_child(hsv_box)
        box.append(hsv_frame)

        # Hex section
        hex_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        hex_label = Gtk.Label(label="Hex:")
        self.hex_entry = Gtk.Entry()
        self.hex_entry.set_text(self.hex_value)
        self.hex_entry.connect("changed", self.on_hex_changed)
        hex_box.append(hex_label)
        hex_box.append(self.hex_entry)
        box.append(hex_box)

        # Copy button
        copy_button = Gtk.Button(label="Copy to Clipboard")
        copy_button.connect("clicked", self.on_copy)
        box.append(copy_button)

    def draw_color(self, area, cr, width, height):
        cr.set_source_rgb(self.r / 255.0, self.g / 255.0, self.b / 255.0)
        cr.rectangle(0, 0, width, height)
        cr.fill()

    def update_from_rgb(self):
        if self.updating:
            return
        self.updating = True
        self.hex_value = rgb_to_hex(self.r, self.g, self.b)
        self.hex_entry.set_text(self.hex_value)
        self.h, self.s, self.v = rgb_to_hsv(self.r, self.g, self.b)
        self.h_spin.set_value(self.h)
        self.s_spin.set_value(self.s)
        self.v_spin.set_value(self.v)
        self.color_area.queue_draw()
        self.updating = False

    def update_from_hsv(self):
        if self.updating:
            return
        self.updating = True
        self.r, self.g, self.b = hsv_to_rgb(self.h, self.s, self.v)
        self.hex_value = rgb_to_hex(self.r, self.g, self.b)
        self.hex_entry.set_text(self.hex_value)
        self.r_spin.set_value(self.r)
        self.g_spin.set_value(self.g)
        self.b_spin.set_value(self.b)
        self.color_area.queue_draw()
        self.updating = False

    def update_from_hex(self):
        if self.updating:
            return
        rgb = hex_to_rgb(self.hex_value)
        if rgb:
            self.r, self.g, self.b = rgb
            self.updating = True
            self.r_spin.set_value(self.r)
            self.g_spin.set_value(self.g)
            self.b_spin.set_value(self.b)
            self.h, self.s, self.v = rgb_to_hsv(self.r, self.g, self.b)
            self.h_spin.set_value(self.h)
            self.s_spin.set_value(self.s)
            self.v_spin.set_value(self.v)
            self.color_area.queue_draw()
            self.updating = False

    def on_rgb_changed(self, spin):
        if self.updating:
            return
        self.r = int(self.r_spin.get_value())
        self.g = int(self.g_spin.get_value())
        self.b = int(self.b_spin.get_value())
        self.update_from_rgb()

    def on_hsv_changed(self, spin):
        if self.updating:
            return
        self.h = self.h_spin.get_value()
        self.s = self.s_spin.get_value()
        self.v = self.v_spin.get_value()
        self.update_from_hsv()

    def on_hex_changed(self, entry):
        if self.updating:
            return
        self.hex_value = entry.get_text().strip()
        self.update_from_hex()

    def listen_socket(self):
        while True:
            try:
                conn, addr = self.server.accept()
                data = conn.recv(1024).decode().strip()
                if data == "pick":
                    GLib.idle_add(self.do_pick)
                elif data == "stop":
                    if self.live_mode:
                        GLib.idle_add(self.stop_live)
                conn.close()
            except:
                pass

    def do_pick(self):
        try:
            # Get cursor position
            result = subprocess.run(
                ["hyprctl", "cursorpos"], capture_output=True, text=True)
            if result.returncode != 0:
                return
            pos = result.stdout.strip()
            x, y = map(int, pos.split(', '))
            # Capture small region around cursor
            size = 5
            geom = f"{max(0, x-size)},{max(0, y-size)} {size*2}x{size*2}"
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            result = subprocess.run(
                ["grim", "-g", geom, "-t", "png", tmp_path])
            if result.returncode != 0:
                os.remove(tmp_path)
                return
            magick = subprocess.run(
                ["magick", tmp_path, "-format", f"%[pixel:p{{{size},{size}}}]", "txt:-"], capture_output=True, text=False)
            os.remove(tmp_path)
            if magick.returncode != 0:
                return
            lines = magick.stdout.decode('utf-8').strip().split("\n")
            if len(lines) < 2:
                return
            hex_color = lines[1].split()[2]
            if not hex_color.startswith("#"):
                return
            rgb = hex_to_rgb(hex_color)
            if rgb:
                GLib.idle_add(self.apply_live_color, rgb)
        except Exception as e:
            pass

    def apply_live_color(self, rgb):
        if (self.r, self.g, self.b) != rgb:
            self.r, self.g, self.b = rgb
            self.update_from_rgb()
        self.updating_live = False

    def reset_updating(self):
        self.updating_live = False

    def on_destroy(self, widget):
        self.stop_live()
        if os.path.exists(self.socket_path):
            os.remove(self.socket_path)

    def on_button_press(self, gesture, n_press, x, y):
        if self.live_mode:
            self.stop_live()

    def on_enter(self, controller, x, y):
        self.cursor_over = True

    def on_leave(self, controller):
        self.cursor_over = False

    def on_pick(self, button):
        if self.live_mode:
            self.stop_live()
        else:
            self.start_live()

    def start_live(self):
        self.live_mode = True
        self.timeout_id = GLib.timeout_add(200, self.update_live)
        self.set_cursor(Gdk.Cursor.new_from_name("crosshair"))
        subprocess.run(["notify-send", "Live Color Picker", "Move cursor to pick colors live. Click pick again to stop."], capture_output=True)

    def stop_live(self):
        self.live_mode = False
        if self.timeout_id:
            GLib.source_remove(self.timeout_id)
            self.timeout_id = None
        self.set_cursor(None)
        subprocess.run(["notify-send", "Live Color Picker", "Stopped"], capture_output=True)

    def update_live(self):
        if self.updating_live or self.cursor_over:
            return True
        self.updating_live = True
        threading.Thread(target=self.do_live_capture).start()
        return True

    def do_live_capture(self):
        try:
            # Get cursor position
            result = subprocess.run(
                ["hyprctl", "cursorpos"], capture_output=True, text=True)
            if result.returncode != 0:
                GLib.idle_add(self.reset_updating)
                return
            pos = result.stdout.strip()
            x, y = map(int, pos.split(', '))
            if x == self.last_x and y == self.last_y:
                GLib.idle_add(self.reset_updating)
                return
            self.last_x, self.last_y = x, y
            # Capture small region around cursor
            size = 5
            geom = f"{max(0, x-size)},{max(0, y-size)} {size*2}x{size*2}"
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            result = subprocess.run(
                ["grim", "-g", geom, "-t", "png", tmp_path])
            if result.returncode != 0:
                os.remove(tmp_path)
                GLib.idle_add(self.reset_updating)
                return
            magick = subprocess.run(
                ["magick", tmp_path, "-format", f"%[pixel:p{{{size},{size}}}]", "txt:-"], capture_output=True, text=False)
            os.remove(tmp_path)
            if magick.returncode != 0:
                GLib.idle_add(self.reset_updating)
                return
            lines = magick.stdout.decode('utf-8').strip().split("\n")
            if len(lines) < 2:
                GLib.idle_add(self.reset_updating)
                return
            hex_color = lines[1].split()[2]
            if not hex_color.startswith("#"):
                GLib.idle_add(self.reset_updating)
                return
            rgb = hex_to_rgb(hex_color)
            if rgb:
                GLib.idle_add(self.apply_live_color, rgb)
            else:
                GLib.idle_add(self.reset_updating)
        except Exception as e:
            GLib.idle_add(self.reset_updating)

    def on_copy(self, button):
        clipboard = Gdk.Display.get_default().get_clipboard()
        clipboard.set(self.hex_value)
        subprocess.run(["notify-send", "Color copied to clipboard:",
                       self.hex_value], capture_output=True)


class ColorPickerApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="dev.color.picker",
                         flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.window = None

    def do_activate(self, *args, **kwargs):
        if not self.window:
            self.window = ColorPickerWindow(self)
        self.window.present()


def main():
    app = ColorPickerApp()
    app.run(sys.argv)


if __name__ == "__main__":
    main()
